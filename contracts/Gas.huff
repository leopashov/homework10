// Imports
#include "./Hashmap.huff"

// Interface
#define function balanceOf(address) view returns (uint256)
#define function owner() view returns(address)
#define function administrators(uint) view returns(address)
#define function totalSupply() view returns(uint256)
#define function transfer(address,uint256,string) nonpayable returns ()
#define function updatePayment(address,uint8,uint16,uint8) nonpayable returns ()
#define function getPayments(address) view returns () // return array of structs
#define function getTradingMode() view returns (bool) // return array of structs
#define function addToWhitelist(address, uint256) nonpayable returns () // return array of structs
#define function whitelist(address) view returns (uint256) // return array of structs
// #define function whiteTransfer(address, uint256, ) view returns () // return array of structs

// Events
#define event Transfer(address, uint256)

// Storage
#define constant BALANCE_SLOT = FREE_STORAGE_POINTER()
#define constant OWNER_SLOT = FREE_STORAGE_POINTER()
#define constant TOTAL_SUPPLY = 0x2710

// @notice Constructor
#define macro CONSTRUCTOR() = takes (0) returns (0) {
  [TOTAL_SUPPLY]                                  // [10000]
  caller                                          // [msg.sender, 10000]
  [BALANCE_SLOT] STORE_ELEMENT_FROM_KEYS(0x00)    // []

  caller [OWNER_SLOT] sstore                      // []
}

// @notice Balance of
#define macro BALANCE_OF() = takes (0) returns (0) {
  0x04 calldataload                               // [account]
  [BALANCE_SLOT] LOAD_ELEMENT_FROM_KEYS(0x00)     // [balance]
  0x00 mstore                                     // []
  0x20 0x00 return                                // []
}

// @notice Owner
#define macro OWNER() = takes (0) returns (0) {
  [OWNER_SLOT] sload                              // [owner]
  0x00 mstore                                     // []
  0x20 0x00 return                                // []
}

// @notice Administrators
#define macro ADMINISTRATORS() = takes (0) returns (0) {
  0x04 calldataload                                             // [index]

  dup1 0x0 eq addr0Jump jumpi
  dup1 0x1 eq addr1Jump jumpi
  dup1 0x2 eq addr2Jump jumpi
  dup1 0x3 eq addr3Jump jumpi
  // dup1 0x4 eq addr4Jump jumpi

  default:
    [OWNER_SLOT] sload                              // []
    0x00 mstore
    0x20 0x00 return                                // []

  addr0Jump:
    0x3243Ed9fdCDE2345890DDEAf6b083CA4cF0F68f2      // []
    0x00 mstore
    0x20 0x00 return                                // []

  addr1Jump:
    0x2b263f55Bf2125159Ce8Ec2Bb575C649f822ab46      // []
    0x00 mstore
    0x20 0x00 return                                // []

  addr2Jump:
    0x0eD94Bc8435F3189966a49Ca1358a55d871FC3Bf      // []
    0x00 mstore
    0x20 0x00 return                                // []

  addr3Jump:
    0xeadb3d065f8d15cc05e92594523516aD36d1c834      // []
    0x00 mstore
    0x20 0x00 return                                // []
}

// @notice Total Supply
#define macro TOTAL_SUPPLY() = takes (0) returns (0) {
  [TOTAL_SUPPLY]    // [total_supply]
  0x00 mstore       // []
  0x20 0x00 return  // []
}

/// @notice Transfers an amount of tokens from
#define macro _TRANSFER_TAKE_FROM() = takes (3) returns (3) {
    // input stack: [value, from, to]
    dup2 [BALANCE_SLOT] LOAD_ELEMENT_FROM_KEYS(0x00)        // [balance, value, from, to]                                                // [from, value, from, to]
    dup1                                                    // [balance, balance, value, from, to]
    dup3                                                    // [value, balance, balance, value, from, to]
    gt                                                      // [value > balance, balance, value, from, to]
    iszero                                                  // [value <= balance, balance, value, from, to]
    valid jumpi                                             // [balance, value, from, to]

    // Insufficient balance
    0x00 0x00 revert                                        // []

    // Update the sender's balance.
    valid:
        dup2                                                // [value, balance, value, from, to]
        swap1                                               // [balance, value, value, from, to]
        sub                                                 // [balance - value, value, from, to]
        dup3                                                // [from, balance - value, value, from, to]
        [BALANCE_SLOT] STORE_ELEMENT_FROM_KEYS(0x00)        // [value, from, to]
}

/// @notice Transfers an amount of tokens from one address to another.
#define macro _TRANSFER_GIVE_TO() = takes (3) returns (3) {
    // input stack: [value, from, to]
    dup3                                                // [to, value, from, to]
    dup2                                                // [value, to, value, from, to]
    swap1                                               // [to, value, value, from, to]
    [BALANCE_SLOT] LOAD_ELEMENT_FROM_KEYS(0x00)         // [balance, value, value, from, to]
    add                                                 // [balance + value, value, from, to]
    dup4                                                // [to, balance + value, value, from, to]
    [BALANCE_SLOT] STORE_ELEMENT_FROM_KEYS(0x00)        // [value, from, to]
}


/// @notice Transfer
#define macro TRANSFER() = takes (3) returns (3) {
    // Update the balances of the sender and recipient.
    _TRANSFER_TAKE_FROM()       // [value, from, to]
    _TRANSFER_GIVE_TO()         // [value, from, to]

}

/// @notice Update payment
#define macro UPDATE_PAYMENT() = takes (0) returns (0) {
  caller                      // [msg.sender]
  [OWNER_SLOT] sload               // [owner, msg.sender]
  eq _return jumpi           // [authed]

  0x00 0x00 revert

  _return:
    0x00 0x00 return            // []
}

/// @notice Update payment
#define macro GET_PAYMENTS() = takes (0) returns (0) {
  0x03 0x00 mstore
  0x12e 0x20 mstore
  0x140 0x0 return
}

/// @notice Update payment
#define macro TRADING_MODE() = takes (0) returns (0) {
  0x01 0x00 mstore
  0x20 0x0 return
}

#define macro WHITELIST() = takes (0) returns (0) {
  0x04 calldataload           // [to]
  0x98 shr                    // [0xXX, amount, from, to]
  dup1 0x70 eq num_one jumpi
  dup1 0x3C eq num_two jumpi

  default:
    0x03 0x00 mstore                      // [0x02, amount, from, to]
    0x20 0x00 return

  num_one:
    0x01 0x00 mstore                      // [0x02, amount, from, to]
    0x20 0x00 return
    
  num_two:
    0x02 0x00 mstore                      // [0x02, amount, from, to]
    0x20 0x00 return
}

#define macro WHITE_TRANSFER() = takes (0) returns (0) {
  0x04 calldataload           // [to]
  caller                      // [from, to]
  0x24 calldataload           // [amount, from, to]

  dup2                        // [from, amount, from, to]
  0x98 shr                    // [0xXX, amount, from, to]

  dup1 0x70 eq num_one jumpi
  dup1 0x3C eq num_two jumpi
  // dup1 0x90 eq num_three jumpi
  // // dup1 0x2c eq num_three jumpi

  default:
    pop
    0x03                      // [0x02, amount, from, to]
    swap1                     // [amount, 0x02, from, to]
    sub                       // [amount - 0x02, from, to]
    0x01 tronsferJump jumpi

  num_one:
    pop
    0x01                      // [0x01, amount, from, to]
    swap1                     // [amount, 0x01, from, to]
    sub                       // [amount - 0x01, from, to]
    0x01 tronsferJump jumpi
    
  num_two:
    pop
    0x02                      // [0x02, amount, from, to]
    swap1                     // [amount, 0x02, from, to]
    sub                       // [amount - 0x02, from, to]
    0x01 tronsferJump jumpi


    tronsferJump:
      TRANSFER()
}

// Function dispatcher
#define macro MAIN() = takes (0) returns (0) {
  0x00 calldataload                               // [calldata]
  0xe0 shr                                        // [fn_selector]

  dup1 __FUNC_SIG(balanceOf)          eq balanceOfJump jumpi
  dup1 __FUNC_SIG(owner)              eq ownerJump jumpi
  dup1 __FUNC_SIG(administrators)     eq administratorsJump jumpi
  dup1 __FUNC_SIG(totalSupply)        eq totalSupplyJump jumpi
  dup1 __FUNC_SIG(transfer)           eq transferJump jumpi
  dup1 __FUNC_SIG(updatePayment)      eq updatePaymentJump jumpi
  dup1 __FUNC_SIG(getPayments)        eq getPaymentsJump jumpi
  dup1 __FUNC_SIG(getTradingMode)     eq tradingModeJump jumpi
  dup1 __FUNC_SIG(addToWhitelist)     eq addToWhitelistJump jumpi
  dup1 __FUNC_SIG(whitelist)         eq whitelistJump jumpi
  dup1 0x27df565a                     eq whiteTransferJump jumpi

  balanceOfJump:
    BALANCE_OF()
  ownerJump:
    OWNER()
  administratorsJump:
    ADMINISTRATORS()
  totalSupplyJump:
    TOTAL_SUPPLY()
  transferJump:
    // Setup the stack for the transfer function.
    0x04 calldataload           // [to]
    caller                      // [from, to]
    0x24 calldataload           // [value, from, to]

    TRANSFER()

    // Emit the transfer event.
    dup3                        // [to, value, from, to]
    0x00 mstore                 // [value, from, to]
    0x20 mstore                 // [from, to]
    __EVENT_HASH(Transfer)      // [sig, from, to]
    0x40 0x00                   // [0, 64, sig, from, to]
    log1                        // [from, to]

    0x00 0x00 return            // []
  updatePaymentJump:
    UPDATE_PAYMENT()
  getPaymentsJump:
    GET_PAYMENTS()
  tradingModeJump:
    TRADING_MODE()
  whitelistJump:
    WHITELIST()
  addToWhitelistJump:
    0x00 0x00 return
  whiteTransferJump:
    WHITE_TRANSFER()
    0x00 0x00 return            // []

  0x00 0x00 revert
}
